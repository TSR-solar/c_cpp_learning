## 走进变量
之前我们定义变量，并用变量来存储用函数scanf输入的数据，并用printf输出存储值；   
那么，现在让我们更深入的了解一下变量；  
当要在程序里保存数据时，就需要一个**变量**来保存它；    
用一个变量保存了数据，它才能参加到后面的计算中；    
**不定义变量，函数scanf就无法使用**，因为数据得不到保存；


变量定义的一般形式就是：<类型名称>  <变量名称>；    
int就是一种类型名称，除此之外还有很多种类型名称；   
变量名称自己任意取，只能由字母、数字和下划线 _ 组成，数字不可以出现在第一个位置上，**区分大小写**；   
此外，C语言的关键字（如int）不可以用作变量名称。

利用变量来储存数据时，常用赋值运算符“=”；   
在C语言中，**“=”不表示相等关系，而是赋值动作，是动态过程；**

>如 int a = 114 ；就表示把114储存在a这个变量中，并不代表a和114相等；

除此之外，还可以用scanf一次输入多个变量或者常量，或者是用printf展示多个变量，如以下的例子：(int.c)

```c
#include <stdio.h>
int main()
{
	int atk1 = 0 ;
	int atk2 = 0 ;//定义变量
	const int ATK3 = 10 ;//定义常量
	int originalhp = 100;

	printf("我现在有100滴血;\n
    现在有3名玩家要攻击我;\n
    已知玩家3的攻击为10;\n");

	printf("请输入玩家1的攻击:");
	scanf("%d", &atk1 );
	printf("\n请输入玩家2的攻击:");
	scanf("%d", &atk2 );
	int hp = originalhp - atk1 - atk2 - ATK3;
	printf("\n OK，我现在还剩下%d-%d-%d-%d=%d滴血；\n ",originalhp,atk1,atk2,ATK3,hp);
	return 0;
}
```

**int**为定义变量，不必多说；   
**const int**为定义常量,用const int定义的常量数值永远不会发生变化，因此常用大写字母表示(ATK3)；  
如果想要强行用赋值表达式改变常量数值，会报错；      
const int 的意义在于给予常数名字，从而增强代码的可读性；    
如ATK3即玩家3的攻击，它的数值为10；如想修改玩家3的攻击，只需找到ATK3，而不是10；    
```c
printf("我现在有100滴血;\n现在有3名玩家要攻击我;\n已知玩家3的攻击为10;\n");
printf("请输入玩家1的攻击:");
scanf("%d", &atk1 );
printf("\n请输入玩家2的攻击:");
scanf("%d", &atk2 );
```

这里连续使用多个scanf函数，以输入两名玩家的攻击。  
注意：在函数scanf中，只有输入数据并按回车后，才会执行下面的代码；
同理，碰到scanf后，会暂停读后面的代码；
```c
int hp = originalhp - atk1 - atk2 - ATK3;
printf("\n OK，我现在还剩下%d-%d-%d-%d=%d滴血；\n ",originalhp,atk1,atk2,ATK3,hp);
```

这里的printf一次展示了多个变量；    
想输出几个变量，就在前面放入几个 %d ，用 %d 代替要展示的变量；  
相应地，在后面，要填入等量的变量，中间用逗号隔开，注意变量之间的顺序；

一种代码运行示例：
>我现在有100滴血;
现在有3名玩家要攻击我;  
已知玩家3的攻击为10;
请输入玩家1的攻击:20    
请输入玩家2的攻击:30 (*20 和 30 为运行时自己输入，可更改。*)  
OK，我现在还剩下100-20-30-10=40滴血；

## 更多变量类型

在生活中，常用到小数；  
例如 10/3 ，结果为3.33333333（循环）;  
但如用C语言计算，如 *printf("%d\n",10/3)* ，答案却是3！

这是在C语言中，整数的运算结果只能是整数；  
因为10和3都是整数，所以，3.33333333（循环）进行了向下取整，得到10/3=3。  
如此，便会得到10/3*3=9这样的离谱结果！

此时，有一个解决方案，就是利用C语言中的浮点数。
浮点数就是带小数点的数值。浮点这个词的本意就是指小数点是浮动的，
是计算机内部表达非整数（包含分数和无理数）的一种方式。

如下面的例子：(divider.c)
```c
#include <stdio.h>
int main()
{
	//dividend 被除数	divisor 除数
	int a = 0, b = 0, c = 0, d = 0;
	double g = 0;
	printf("It's a calculator for division.\n");
	printf("input dividend and divisor in order:");
	scanf("%d %d", &a, &b);
	c = a / b; d = a % b; g = a *1.0/ b;
	printf("%d÷%d=%d...%d\n", a, b, c, d);
	printf("%d÷%d=%f\n",a,b,g );
	return 0;
}
```
以10/3为例，得到的结果为：
>10÷3=3...1 ；   
10÷3=3.333333 ；



```c
int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
double g = 0;
```
与int类似，double也是类型名称；  
只不过int类型的变量始终为整数，而double类型的变量始终为浮点数；  
因此，初始值a=b=c=d=e=f=0;  
而g=0.000000（其实还有更多位，但只显示6位小数）

```c
g = e *1.0/ f;
```
需要注意的是，**不能直接写 g = e / f ;**  
因为上面提到，整数的运算结果只能是整数；  
而 e 和 f 都是 int 类型的变量，显然会抹掉结果的小数部分；  
这样，即使 g 是 double 类型的变量，也不会得到正确结果；  
>比如，当 e=10 ，f=3 时，显示 10÷3=3.000000 ;

而不幸的是，虽然问题出在 a 和 b 的类型名称 int 上，更改 int 为 double **并不能**解决问题;  
因为，这样会让 e 变为10.000000， f 变为3.000000；
显示的会是：
>10.000000÷3.000000=3.333333；

虽然结果对了，但是我输入的是整数，来这么多小数干啥！而且**浮点数取余也会出错**；

因此，我们不更改 int 为 double ，而是 **e * 1.0** ；
这样既利用1.0这个浮点数将结果设置为浮点数 3.333333 ，又不会影响结果；最终显示： 
>10÷3=3.333333 

```c
printf("%d÷%d=%f\n",e,f,g );
```
同理，在使用浮点数变量时，函数printf和scanf也有对应的改变；
printf中 **%d 变为 %f** ；scanf中 **%d 变为 %lf** ；

### 用了%d会发生什么
如果在 double 类型的变量中，用了%d会发生什么?  
下面是关于上述问题的探究。

1.编写以下代码(%d-test.c)，输入1，观察输出结果；

```c
#include <stdio.h>
int main()
{
	int a ;
	scanf("%d", &a);
	printf("%d\n",a);
	return 0;
}
```
   2.改变变量类型名称，printf，scanf，重复上述操作

   3.输出结果记录如下：

| 定义   | scanf | printf | 输入*1*后的输出                                              |
| ------ | ----- | ------ | ------------------------------------------------------------ |
| int    | %d    | %d     | 1                                                            |
| int    | %d    | %f     | 0.000000                                                     |
| int    | %lf   | %d     | 0（代码报错）                                                |
| int    | %lf   | %f     | 0.000000（代码报错）                                         |
| double | %d    | %d     | 1                                                            |
| double | %d    | %f     | -92559592117457364459447783688012762948756726027711679117131776.000000(*就离谱*) |
| double | %lf   | %d     | 0                                                            |
| double | %lf   | %f     | 1.000000                                                     |

结论：只有 printf 和 scanf 与变量类型**配套**，才能输出正确结果，否则输出**离谱结果**！

## 数据类型
我们已经知道：C语言是有类型的语言；    
C语言中的类型包含整数类型、浮点数类型、字符类型、逻辑类型、以及指针和自定义类型；
接下来将详细讲解整数类型、浮点数类型、字符类型和逻辑类型；
指针和自定义类型放到后面再讲；

### 整数类型
整数包括5种类型；  
分别是 short char int long 和 long long ；
它们的字节数不同；  
char      1 (8 bit)  
short     2  
int       取决于编译器类型；一般为4个字节；  
long      4  
longlong  8
具体可通过sizeof函数查验。  
以int类型为例：(sizeof.c)

```c
#include <stdio.h>
int main()
{
	printf("%d\n", sizeof(int));
	return 0;
}
```
可以看到输出结果是4；代表本编译器int类型变量为4个字节；

bit是什么呢？
就是二进制中的一个数，因此8个二进制数就表示一个字节；

#### 补码
在计算机内部，一切都是二进制数，所有数都可以用二进制数表达；  
那么，负数如何表达?   
>答：补码

**一个正数的相反数与其相加可以得到0**；  
利用这个特性可以用补码来表达二进制下的负数；  
>例如，对于char类型的变量，因为是一个字节，所以可以表达2^8=256个数；比如1是0000 0001；  
已知-1+1=0；那么与0000 0001相加等于0的自然就是-1；  
事实上，对于char类型的变量，我们只需得到**八位是零**即可，剩下一位会**溢出**；  
因此，相加等于1 0000 0000即可；
所以-1就是1111 1111，它就是0000 0001的补码；

这样做，会使变量在**正数范围**表达的数**变少**；  
比如1111 1111如不当作补码看待，就是255；  
为了不重复，char类型的变量范围将从0~255变为-128~127；  
其中-128是1000 0000；127是0111 1111；  
以此类推，short可以表达-32768~32767的整数;  
而int、long、long long就更多了；  
一个数的正负，**主要看最高位**，若为1则是负数，若为0则是正数或0；

如果想让char类型的变量范围变回0~255，可以在前面加上**unsigned**；  
比如，unsigned char的1111 1111 表达的就是255；
但它仍不能表达高于255的数；

如果超出了数据范围进行运算，变量可能会越界并溢出；
如下面的例子(full.c)：
```c
#include <stdio.h>
int main()
{
    char a = 127;
	a = a + 1;
	printf("a=%d\n", a);
	return 0;
}
```
输出结果：
>a = -128；

这是因为0111 1111 + 0000 0001 = 1111 1111   
而1111 1111 根据补码就是-128；  
同理，也可以得到 -128+1=0这样的离谱结果；

在初始化变量的值时，输入的值默认为int类型；
如果想要输入其它形式，可以加上后缀字母；
比如，加上u可以输出unsigned；加上l可以输出long和longlong；  
此时可以省略int；

除了后缀，数字还可以加上前缀；
前缀一般表示数的进制；
比如八进制在数字前面加上0，十六进制在数字前面加上0x；

> 比如,输入012,就是十进制的10;  
输入0x12，就是十进制的18；

对于在scanf和printf中整数的输入输出，之前提到了%d；
事实上，一共有4种形式：

| %d   | %u             | %ld             | %llu                     |
| ---- | -------------- | --------------- | ------------------------ |
| int  | unsigned (int) | long long (int) | unsigned long long (int) |

其中字节小于等于int的变量，即char、short、int都按int类型输入输出；  
字节大于int的变量，即long和long long都按long long类型输出；

此外，还有%o和%x，它们分别表示八进制数和十六进制数，且输出的数不带有前缀；
### 浮点数类型
在数据类型中，与整数相对的就是浮点数；  
浮点数包括三种类型，分别是：float、double、long double；  
它们的内存分别是8个字节、16个字节、32个字节；  
由于long double极少用到，这里只介绍float和double；

float变量的范围为  ±(1.2e-38~3.4e38)和0；  
double变量的范围为 ±(2.2e-308~1.79e308)和0；  
这代表它们在极其接近0的部分仍有一小部分数无法表达（不包括0）；

此外，浮点数可以输出 ±inf 和 nan；  
inf即infinite，即无穷大；  
>与一般的算数规则不同，正数除以0可以得到+inf，负数除以0可以得到-inf；

nan即not a number，表示非数；即不存在的数；  
>0除以0可以得到nan；

另外，由于计算机内部的数均为二进制数，对于小数位数过多的数，计算机只能以近似的数去拟合；  
这就是说，浮点数的范围区间并不是连续的，而是离散的；  
拟合的精度有限。所以把浮点数准确的小数位数称为有效位数；
float的有效位数为7，double的有效位数为15；
所以double又叫“双精度浮点数”；
因此，当两个浮点数的差小于1e-7时，就可以认为它们是相等的了；  
用 == 判定两个浮点数相等反而是错误的；

与整数类似，浮点数输入输出也有其特定形式；
float输入用%f，输出也用%f；
double输入用%lf，输出用%f；

此外，还可以用%e输出，此时输出的是浮点数的科学计数法；
浮点数输入可直接使用科学计数法形式；

浮点数的二进制表达形式一般如下：  
以double为例，它由64bit；
第一位（最高位）用来记录数的正负（补码）；
2-12位用来记录浮点数的数量级；  
后面的位用来表示浮点数的有效数字；  
由于用来表达有效数字的bit终究是有限的，所以在小数位数过多时会产生误差；

正如整数输入的类型默认为int，浮点数输入的类型默认为double；
想要表达float可以在数字后面加上f；

如果没有特殊需要，整数类型用int，浮点数类型用float就行了；

### 字符类型
char除了表示整数，还可以表示字符；  
因为char是character的缩写；  
除了字母、符号，数字同时也可以是字符；

输入输出char类型变量可以使用**%c**；

由于计算机内部全部是二进制数，因此要想办法把字符转换为二进制数；  
因此要使用ASCII编码，每个字符与ASCII中的一个数字编码一一对应；  
再将ASCII编码转换为二进制数，就能实现字符在计算机内部的表达；

想要初始化char类型的变量为字符，不管它是不是数字，都必须加上单引号； ‘1’，以将字符变量和一般变量做区分；  
如果数字没加单引号，char将会存储数字对应的ASCII编码的字符；  
如果非数字没加单引号，如果这不是一个变量，**会报错**；  
值得一提的是，‘’也是一个字符，即使单引号里面没有任何东西；  
它的ASCII码是0；

字符也可以进行计算，但实际计算的是字符的ASCII编码；
比如， 一个字符加一个数字得到ASCII码表中加上那个数之后的字符；
两个字符运算，先将字符转换为ASCII编码，算完后再转换为字符；
如下面的例子(char.c)：
```c
#include <stdio.h>
int main()
{
	char x = 'a' + 1;
	char y = 'b'-'a';
	printf("%c\n",x);
	printf("%d\n",y);
}
```
输出结果：
>x=‘b'；y=1

除此之外，还有一类特殊的字符，称为“逃逸字符”；  
它们以反斜杠 \ 开头，作用是控制 **printf** 输出的内容；
逃逸字符主要包括以下这些：

| \b       | \ "    | \t             | \ '    | \n   | \ \        | \r   |
| -------- | ------ | -------------- | ------ | ---- | ---------- | ---- |
| 回退一格 | 双引号 | 到下一个表格位 | 单引号 | 换行 | 反斜杠本身 | 回车 |

> 其中\t可以起到让数据在表格位对齐的作用（即输入一个TAB键）；

#### 类型转换

类型转换分为自动类型转换和强制类型转换；   
当运算符(双目)的两个变量类型不同时，会发生自动类型转换；   
自动类型转换很简单，一般是把小的往大的转换；  
比如把整数转换为浮点数，内存小的转换为内存大的；


有时，我们需要在各个变量类型之间做转换；
这时，我们就要用到强制类型转换符；
它的格式是 （类型名）值；  
如下面的例子：
>int a;  
a= (int) 3.5;  
则a的值为3；

同时强制类型转换也是一个运算符；  
它的优先级为1，比任何运算符都高；

### bool类型
boll类型更像是逻辑类型。它的值**只能是0和1**；  
0非1是；  
因此，使用bool类型可以加快代码运行速度；