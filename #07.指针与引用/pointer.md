## 前言
根据学习经验，指针是C语言最困难的地方；  
其原因不仅在于需要理解地址、访问等计算机底层概念，更为抽象；  
而且指针**仅在C语言和C++语言**中存在，没有其它语言作为基础；   
但是指针的用处十分广泛，内存分配、文件操作等都离不开指针；  
并且学习指针还能对计算机系统有一定的认识；  
故曰：学习指针是掌握C语言过程中必不可少的步骤；

## 地址: 数据存放点
地址代表一个变量存放的位置；  
运算符 & 可以用于获取变量的**地址**，但是它必须针对一个**变量**操作；  
地址一般使用十六进制表示；  
因此scanf函数运作的真正原理是将输入的数据存入**指定的地址**中；  
而不是直接赋值；  
除此之外，我们还可以使用 %p 来获取一个变量的地址；  

例如下面的程序可以看到变量 i 的地址；(address.c)

```c
#include <stdio.h>
int main()
{
	int i = 114;
	printf("&i=%X\n", &i);
	printf("&i=%p\n", &i); //仍需输入&；
    return 0;
}
```
输出结果如下：	
>&i=12FF8D0  
&i=012FF8D0

可以看到，虽然上下两行代码几乎相同，但是上下两个结果并不相同；
其中下面的地址多了一位；   
除此之外，编译器可能还会有一个警告，叫做：
>“printf”: 格式字符串“%X”需要类型“unsigned int”的参数，但可变参数 1 拥有了类型“int *”

这是因为编译器的架构不同；  
%X输出的是整型 int ，而%p输出的是地址的**专属变量类型 int***；    
因此要获取一个变量的地址**最好还是使用%p**；

## 指针：快捷访问

### 指针取地址
前面谈到了 int* ；这就是指针类型的变量；  
指针变量也是储存值的，只不过存的是存放具体值的变量的地址；  
>用 int *p = &i;

p就可以储存具有实际值的变量i的地址；  
换句话说，**p指向了i**（ p->i ）；

需要注意的是，`int *p = &i`中，**&不可以省略**，因为你要赋地址给指针；  
而`int *p = i`，给指针 p 传递的是 i 的值；编译器会直接报错；

我们将i的地址赋给了指针p；在输出指针p指向的i的地址时，**与&i完全一致**；

#### NULL: 空地址
除此之外，我们还可以用**NULL**来表示一个没有指向任何地址的**空指针**；  
当我们试图找到它的地址时，你就会发现它是0或者是null；

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。
>注意：如果没有给指针赋值，会发生严重的编译错误!!

#### void* : 迷失的指针
指针如变量一样有许多类型；但还有额外的类型，就是 void* 类型；  
它表示该指针所指的**变量类型未知**；  
由于变量类型未知，所以**无法通过**取值运算符访问指针所指的变量数值；
但变量本身类型没有变化；  
void* 类型所占的字节数也为1；  
目前暂时没想到它有什么用。


### 对地址取值
前面提到运算符 & 可以访问变量所在的地址；  
那么反过来，我们有运算符 * ，可以找到**地址所在的变量的值**；  
具体看下面的例子：(pointer.c)
```c
#include <stdio.h>
int main()
{
    int i = 114;
    int *p = &i;
    int *q = NULL;
    printf("p=%p\n",p);
    printf("q=%p\n",q);
    printf("i=%d\n",i);
    printf("*p=%d\n",*p);
    return 0;
}
```
输出结果：
>p=001BFD70  
q=00000000  
i=114  
*p=114  

*p 找到了指针p储存的地址指向的变量i，因此输出i的值，上下两行结果**完全一致**；  
可以理解为：*先访问到了p的地址指向的是变量 i ，之后 *p 再**将 i 拿来运算**；  
由此可见，运算符*和&作用相反，**互为逆运算符**；

| 优先级 | 运算符 | 运算 | 结合关系 | 举例          |
| ------ | ------ | ---- | -------- | ------------- |
| 2      | 取值   | *    | 自右向左 | *p（p为指针） |
| 2      | 取地址 | &    | 自右向左 | &i（i为变量） |

## 指针之力： 跨函数使用

事实上，在大部分情况下， `*p` 可以看作 i；&i 可以看作 p ;  
那要这两个运算符和指针有啥用额？  
答案就是：跃过函数赋值！    
我们知道，函数与main之间，只能用值连接，二者其中的变量毫不相干；  
但有了指针，一切就改变了，因为**地址只有一个**，函数形参和实参的地址是**相同**的！  
如下面的例子：(pointerInFunction.c)
```c
#include <stdio.h>
void changeInFunction(int *p)
{
    *p=514;
}

int main()
{
    int i=114;
    int *p=&i;
    printf("former: i=%d\n",i);
    changeInFunction(p);
    printf("after: i=%d\n",i);
    return 0;
}
```
输出：
>former: i=114;  
after: i=514;  

尽管位于不同的函数，但i的地址是唯一的；  
而指针p指向的又是同一个地址；  
因此相当于p直接访问到了 main 中的 i，并“隔空”进行了替换；  
在函数的最后，指针p作为形参同样被抹去了；  
但地址里的变量i已经被修改了；    
因此前面i的值还是114，后面就变成514了；

## 指针与数组
### 数组 -> 指针
告诉你们，数组就是特殊的指针！！  
已知运算符 * 可以访问指针指向的变量的值；  
同理， * 也可以访问数组“指向”的变量，即**数组储存的第一个变量**a[0]；  

自然，数组也可以有“跃过函数赋值”的操作；

除此之外，用数组定义指针时不用加& ；  
因为不加[]的数组标识符就是特殊的指针；

如下面的例子：(pointerAndArray.c)
```c
#include <stdio.h>
void changeInFunction(int a[])
{
    *a+=1;
    a[1]+=1;
    a[2]+=1;
}

int main()
{
    int a[]={1, 2, 3};
    int *p=a;	// *p=&a[0];
    printf("a[0]=%d; *a=%d;\n",a[0],*a);
    printf("p[0]=%d; p[1]=%d; p[2]=%d;\n",p[0],p[1],p[2]);
    printf("a[0]=%d; a[1]=%d; a[2]=%d; (former)\n",a[0],a[1],a[2]);
    changeInFunction(a);
    printf("a[0]=%d; a[1]=%d; a[2]=%d; (after)\n",a[0],a[1],a[2]);
    return 0;
}
```
输出结果：
>a[0]=1; *a=1;  
p[0]=1; p[1]=2; p[2]=3;  
a[0]=1; a[1]=2; a[2]=3; (former)  
a[0]=2; a[1]=3; a[2]=4; (after)  

可以看到 a[0] 和 *a 的值完全一致，都是1；  
类比于指针，我们可以解释为 * 访问了 a “指向”的变量，正好它就是a作为数组时储存的变量a[0]；

在函数changeInFunction中，无论是 *a 还是 a[1] a[2] 都能成功地对数组a的值进行改动；
因此，b[1] b[2] 也是取值运算符；它们也是直接访问到 b[1] b[2] 指向的变量的地址，并“*隔空*”修改变量的值；

### 指针 -> 数组

以此类推，在某些情况下，指针也可以**当作数组**，使用[ ]；  
还是上面的例子。
>p[0]=1; p[1]=2; p[2]=3;  
a[0]=1; a[1]=2; a[2]=3;

可以看到 p[0],p[1],p[2] 的值和 a[0],a[1],a[2] 的值完全一致；  
可以解释为p[0]作为1个变量“储存”了1个值，  
而这个值就是 p 作为指针时访问到的变量 i 的值；

对于数组而言,数组储存的变量的地址都是连续的；  
这也就意味着指针也有机会以数组访问的方式访问自己以外的数组变量；  
也就是说，可以出现`p[-1]`这样的东西 (只要地址前面有变量)；  

### 数组 VS 指针
数组与指针的不同之处，在于数组指向的地址不可以被改变；  
比如，你不能进行a++来试图改变数组a指向的地址，它永远是&a[0]；  
这一点和常数const int 很像：一旦被定义，就不能再被改变；  
实际上，`int a[ ]` 实际上**等价**于 `int * const a` ；代表**指针a是常量**；
数组就是指向的地址不能被改变的常量指针！

除此之外，需要区分的是，还有另一种常量指针，就是 `const int *a`；  
它的意思是 `*a`是常量；  
也就无法通过*a或a[0]这些方式来改变它所指的变量的值；  
但它指向的地址可以被改变，即 a++是可行的；

这两种常量指针的区别在于 **a 是常量还是 *a 是常量**；  
例如，`int const *a`；就是 *a 是常量，与第二种常量指针一致；

当数组被定义成常量时，（ `const int a[]` ）
此时数组储存的每一个变量都是常量，同时所指的地址也不能被修改；
等价于 `const int * const a`；

指针的好处在于可以跃过函数；但它的坏处也在于此：无需限制就把你外面的变量修改了；  
因此，就可以在函数里面使用常量指针（或数组）；  
一旦你用取值运算符做了修改，编译器就会**报错**,  
相当于在运行前就发现了错误；  
这样就可以保护指针类型的变量不会改变外面的值；

## n重指针
除此之外，还有指针数组和指向指针的指针；  
理论上可以用指针数组来表示字符串数组，  
但是感觉没有二维数组那么方便；

## 指针运算
指针也可以用于运算，可以对一个指针进行加减常数；  
运算后的结果就是指针所指的地址加或减了一个数字；  
注意：加减的数字必须是指针字节内存的倍数！  

或者是自增自减，结果是向前移动**一个字节**（4bit）内存大小；

除此之外，两个指针之间也可以相减；  
得到的是指针之间的字节数**减一**，再除以变量的字节长度；  
如以下的程序：(calculateInPointer.c)

```c
#include <stdio.h>
int main()
{
    int a[6]={0};
    int *p=&a[0];
    int *q=&a[6];
    printf("q-p=%d\n",q-p);
    return 0;
}
```

由于a[0]和a[6]之间有28个字节；  
所以减一后除以4 `sizeof(int)`，最后输出6；（6-0=6）

另外，两个指针之间也可以做比较，依据是它们的地址；  
主要包括以下两种：  
相等性比较 (== 和 !=)  
关系比较 (<, <=, >, >=)

## 动态内存分配
### 借空间
在实际情况中，有时我们事先不知道数组的内存，或者数组的内存要循环使用；  
由于定义数组长度时必须使用常数，而数组长度又不可变，  
因此分配内存时极易造成数组越界或者空间浪费、内存溢出；  
这时，我们就需要使用malloc函数，来进行动态内存分配；  
所谓动态内存分配，就是内存可以**随时分配**和**释放**；

不过在使用malloc系列的函数时，我们要先加入如下头文件：  
`#include <stdlib.h>`  

malloc函数的使用方法是在malloc函数中用小括号输入一个数字，这个数字就是指针的内存大小（单位：字节）  
注意：指针返回的就是 void 类型的指针，所以还需要用强制转换运算符来把malloc得到的内存返回；   
然后就可以把指针当作大小确定的数组使用了；

### 还空间
malloc函数是从系统内存中借来的连续空间，不是自己地址的空间；  
所以，使用完数组之后，还得还给系统；  
这时就需要使用free函数；

如下面的例子：(malloc.c)
```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
	int i=0;
	int *a=&i;
	a=(int*) malloc(4*sizeof(int));
	free(a);
	return 0;
}
```

当你没有使用free函数时，占用的内存就会积累下来，直到程序结束再释放；  
如果你非常不幸地把内存用完了，malloc找不到新的内存了，就会返回0地址；  
而若返回了0地址，程序立即结束；

值得一提的是，free函数只能释放申请来的地址，而地址不能有任何变化；
这也就是说，a++后就不能再使用free函数；