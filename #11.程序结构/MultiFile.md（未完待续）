## 前言
随着编程的发展，程序的结构变得越来越复杂；  
用单个源文件来编写整个程序越来越难以实现；  
因此，必须要学习多文件程序结构，将程序设计的重点放在多文件架构下变量、函数的迁移以及程序的组织方面；

## 不死之身：全局变量
全局变量定义在大括号外面，因此它们在整个程序中都有效，**不会消失**。  
但是，伴随着的就是长期的**内存占用**和对程序模块化的**破坏**；

需要注意的是，全局变量在作用域内会被同名的局部变量顶替。  
即：大的作用域服从于小的作用域；  
如下面的例子(global.c)：
```c
#include <stdio.h>
 
// 全局变量声明
int g;
 
int main ()
{
    // 局部变量声明
    int a, b;

    // 实际初始化
    a = 10;
    b = 20;
    g = a + b;

    printf("%d\n",g); // 这里可以正常调用变量g;

    return 0;
}
```

## 变量修饰：静态与动态存储
前面提到，全局变量可以长期的占用内存空间；  
那么，对于局部变量，是不是也能实现静态存储呢？  
答案是肯定的。我们可以通过修饰变量来改变它的存储方式；

一般来说，变量的存储方式分为3种；  
静态的就是静态存储；  
动态的有自动存储和自由存储；

### 静态存储
在定义变量时前面加上static来使变量变为静态变量；  
`static int a = 10;`  
完了以后它的作用域将会扩大，但是与全局变量不同的是，它无法超越它所在的函数；

一个静态变量如果没有被初始化，默认为0；而且它只认第一次初始化；**（实例以后补充，请提醒我）**  
全局变量也是如此，但局部变量不同，它会变成一个随机的值，有机会造成**食物中毒**。

还是那句话，静态的东西尽量少用；

### 自动存储
这是系统默认的存储，即定义的时候分配空间，作用域结束的时候销毁；
实现这个存储你啥都不需要加，如果**硬要**的话也可以加个**auto**；  
`(auto) int a = 10;`

### 自由存储
自由存储指的是按照程序员的意愿指定空间分配和释放的时机，具有极大的自由性；  
但是缺点是容易忘记，分配倒还好，主要是忘记释放或者忘记已经释放；

自由存储只能通过函数和指针实现，即<stdlib.h>里面的malloc和free函数；

## 变量声明：extern
类似于函数，变量也有声明；  
但是怎么区分声明与定义？  

函数倒还好，不写函数体就是声明了；  
但变量呢？不初始化？那是未赋初值的变量的定义，不是声明；

因此，我们特地引入符号extern，来表示一个变量的声明；  
`extern int a`  
有了声明，就能够在定义的前面调用变量；
但是，与函数不同的是，变量声明后不能初始化；
>比如，`extern int a = 10;`  是错误的；  

由于定义包含声明，所以变量的声明看似没有多大用处；  
但是，在多文件结构中，变量的声明是极其有用的；  
它可以在不同的源文件中分离声明和定义，以达到程序模块化的效果；

## 函数修饰：内部与外部
函数修饰仅存在于多文件结构中，因为单个源文件没有**内部**和**外部**的说法；

函数修饰分为内部修饰和外部修饰；

### 内部修饰
在函数定义的前面加上**static**进行内部修饰；  
```c
static int fun(int, int)
{
    ... // 函数体
}
```
函数进行内部修饰后，仅在当前源文件中有效，其它文件无法调用这个函数，要想用只能自己重新定义；

### 外部修饰
函数默认为外部修饰，因此加不加**extern**都无所谓了；  
外部修饰保证函数在整个多文件结构中有效；想要调用只需要声明就可以了；

## 多文件结构
多文件结构程序允许多个源程序存在；  
如果要把它们放在一起运行，应该首先分别编译成.o可重定位文件，再使用连接器把所有.o和一些杂七杂八的库函数连接在一起，生成可执行应用程序；  
另外，头文件和工程文件也是多文件程序十分有用的结构；

### 头文件
头文件就是一大堆函数的声明和宏、全局常量的集合；  
为什么要头文件呢？之前说过，源文件如果想要调用外部函数，那么就必须要先声明；  
如果有很多个源文件，就要写很多次；这不仅麻烦，还不利于修改。  
但是，头文件就可以把这些所有的声明集合到一起，之后在每个程序里边只需要一句`#include`就可以了；

### 工程文件
如果有很多个源文件，那么必须要把它们分别编译成.o文件以后才能连接，这样就要执行很多条指令，非常碍事；  
但是，如果我们使用工程文件，就可以自动执行编译与连接，简化操作；

常见的工程文件就是Makefile，把它编写好以后仅需要在命令行输入一句`make`就可以启动自动编译；

这里不展开，因为实际上我也不会编写makefile(