# 任务自动化：预处理
## 宏定义#define
#define 是**宏**，可以将代码中所有与预处理变量**相同**的式子**替换**为处理后的式子。  
为避免混淆，宏定义的常量也用大写字母表示;  
如果要取消怎么办？使用`#undef`即可。  
取消之后就可以对宏进行重新定义，否则宏**不能重复定义**；

不过，需要注意的是，#define只能简单粗暴的做替换工作，不能运算。  
>如果`#define A 3+2`；  
那么 2*A 的结果就会是8而不是10.  
因为实际上代码被替换为了 `2*3+2` 而不是 `2*(3+2)`;  

勤加括号可以避免这一类问题的出现。

### 已有的宏定义

除此之外，有些宏已经在头文件里面预处理好了，直接当作一般的变量使用就行；  
他们有：  
>`__DATE__  __TIME__  __FILE__  __LINE__  __STDC__`  
(注意是两横)  
分别表示编译程序时的日期、时间、文件名、当前源代码的行号、是否兼容ANSI C标准；

宏定义可以使代码变得更加**简洁可读**；

如下面的例子(define.c)：
```c
#include <stdio.h>
 
#define LENGTH 10   
#define WIDTH  5
 
int main()
{
 
    int area;  
    area = LENGTH * WIDTH;
    
    printf("%d\n",area);

    printf("%s\n",__DATE__);
    printf("%s\n",__TIME__);
    printf("%s\n",__FILE__);
    printf("%d\n",__LINE__);
                                
    return 0;
}
```
输出结果：
>50  
(剩下的内容因人而异，请自行尝试)

### 带参数的宏定义
宏定义里面可以带参数；比如下面这个例子：  
`#define max(a,b) ((a)>(b)?(a):(b))` 

与不带参数的宏区别的地方是，带参数的在后面会给出一个**参数表**，并在宏调用时用main函数提供的参数来填充宏里面的未知数；  
如上面的宏将会把所有的a和b都用数字替代；  
这看起来很像函数的参数调用；但是二者却有不同，原因是宏在调用时会进行多次参数运算；

### `#`作为运算符
除预处理宏之外，#还是个**运算符**；另外##也是个运算符；  

#运算符的作用是将文本参数“**字符串化**”，也就是说可以去掉双引号；  

##运算符的作用是把两个字符文本**连接**为一个字符文本，也就是说，宏的替换会在连接之前就发生；  
于是，我们可以对一个字符串中的**部分**内容替换而**不需要加空格**；

>比如，  
#define PRINT(x) printf(#x)  
#define SET(arg) A##arg=arg  