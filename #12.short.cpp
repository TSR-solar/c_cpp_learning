/*
C语言是有类型的语言；
包含整数类型、浮点数类型、字符类型、逻辑类型、以及指针和自定义类型；
东西太多了，这里只讲整数类型；
*/

/*
整数包括5种类型；
分别是 short char int long和long long ；
它们的字节数不同；
char      1 (8 bit)
short     2
int       取决于编译器类型；一般为4个字节；
long      4
longlong  8
*/
//具体可通过sizeof函数查验（以int类型为例）：

#include <stdio.h>
int main()
{
	printf("%d\n", sizeof(int));
	
//可以看到输出结果是4；代表本编译器int类型变量为4个字节；

/*
bit是什么呢？
就是二进制中的一个数，因此8个二进制数就表示一个字节；
*/
/*
在计算机内部，一切都是二进制数，所有数都可以用二进制数表达；
那么，负数如何表达?
答：补码
一个正数的相反数与其相加可以得到0，利用这个特性可以用补码来表达二进制下的负数；
例如，对于char类型的变量，因为是一个字节，所以可以表达2^8=256个数；比如1是0000 0001；
已知-1+1=0；那么与0000 0001相加等于0的自然就是-1；
事实上，对于char类型的变量，我们只需得到八位是零即可，剩下一位会溢出；
因此，相加等于1 0000 0000即可；
所以-1就是1111 1111，它就是0000 0001的补码；

这样做，会使变量在正数范围表达的数变少；
比如1111 1111如不当作补码看待，就是255；
为了不重复，char类型的变量范围将从0~255变为-128~127；
其中-128是1000 0000；127是0111 1111；
以此类推，short可以表达-32768~32767的整数，而int就更多了；
一个数的正负，主要看最高位，若为1则是负数，若为0则是正数或0；
*/

/*
如果想让char类型的变量范围变回0~255，可以在前面加上unsigned；
比如，unsigned char的1111 1111 表达的就是255；
但它仍不能表达高于255的数；
*/

/*
由于采用了补码形式，变量在进行运算时可能会越界；
*/
//如下面的例子：
	char a = 127;
	a = a + 1;
	printf("a=%d\n", a);
	return 0;
}
/*
可以看到a = -128；
这是因为0111 1111 + 0000 0001 = 1111 1111 而1111 1111 根据补码就是-128；
同理，也可以得到 -128+1=0这样的离谱结果；

将变量变为unsigned可以解决越界问题，因为它去除了补码的设定，只进行纯二进制的计算；
*/

/*
在初始化变量的值时，输入的值默认为int类型；
如果想要输入其它形式，可以加上后缀字母；
比如，加上u可以输出unsigned；加上l可以输出long和longlong；
*/

/*
除了后缀，数字还可以加上前缀；
前缀一般表示数的进制；
比如八进制在数字前面加上0，十六进制在数字前面加上0x；
*/

/*
对于在scanf和printf中整数的输入输出，之前提到了%d；
事实上，一共有4种形式：
%d：int
%u:unsigned int
%ld:long long
%lu:unsigned long long
其中字节小于等于int的变量，即char、short、int都按int类型输入输出；
字节大于int的变量，即long和long long都按long long类型输出；
此外，还有%o和%x，它们分别表示八进制数和十六进制数，且输出的数不带有前缀；
*/