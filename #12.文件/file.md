## 数据持久化：文件
通常我们根据和终端进行输入输出来进行交互；  
这样虽然方便，但是无法长期的存储数据；  
因此，我们需要一个新的内容，它可以长期的储存像文本、应用程序一样的数据，它就是**文件**；

文件系统根据操作时交换区的情况又分为缓冲区文件系统和非缓冲区文件系统；

### 缓冲区文件系统
缓冲区文件系统包括一个用于内存和磁盘之间的名叫缓冲区的交换区；  
它为每一个正在使用的文件开辟了一片临时空间；  
所有对磁盘中对文件的操作都会先由内存进入缓冲区临时储存，当缓冲区满后再一起送到磁盘中去长期保存；  
这样的好处就是存取效率高，但是有概率发生缓冲区数据丢失；

### 非缓冲区文件系统
非缓冲区文件系统没有缓冲区这个交换区，一切文件操作都是内存和磁盘二者直接进行的；  
非缓冲区虽然几乎不会发生数据丢失，但是存取效率会低很多；  

C语言文件操作使用缓冲区文件系统，因此下面文件操作都是基于缓冲区文件系统进行的；

## 文件在C程序中的表示
注：文件的操作函数大部分都在标准输入输出头文件`stdio.h`里面；  
不需要额外定义函数、结构体之类的东西；

可以使用结构体`FILE`来定义一个文件指针变量；  
当文件指针变量指向了一个文件时，就可以通过指针来对文件进行操作；  
```c
typedef struct _iobuf
{
    char *_ptr;         // 文件位置指针
    int _cnt;           // 缓冲区剩余字符数
    char *_base;        // 缓冲区首地址
    int _flag;          // 文件状态标志
    int _file;          // 文件有效性检查
    int _charbuf;       // 若无缓冲区则不读取字符
    int _bufsize;       // 缓冲区大小
    char *_tmpfname;    // 临时文件名
} FILE;     // 定义文件结构体

FILE *fp;   // 定义一个文件指针变量
```
然而结构体里面的大部分内容，我感觉现在都用不到； 

## 文件的打开与关闭  

在定义了一个文件指针变量后，接下来的任务就是要让它指向一个文件；  
这时候就需要用到文件打开函数`fopen`；
与此同时还有文件的关闭函数`fclose`，它们的原型如下：
```c
FILE *fopen(const char *filename,const char *mode);
int *fclose(FILE stream);
```

### 文件的打开
`fopen`函数里面的2个参数分别代表文件名、打开模式；

#### **filename**
`filename`是一个字符串，指示将要打开的文件名，比如`file.md`；  
值得注意的是，这样写的话只能打开本目录（即**源程序所在目录**）的文件；  
如果想要打开其它地方的文件的话，就要使用**相对路径**或者**绝对路径**；  
比如，现在想要打开本文件夹的以下文本文件，需要在`filename`处填入如下字符串：
```c
a.txt   // 当前目录下的a.txt文件

// 相对路径（注意，斜杠应该表达成转义字符双斜杠“\\”形式）
sub\\b.txt  // sub子目录下的b.txt文件
..\\c.txt   // 上一级目录下的c.txt文件

// 绝对路径（因为绝对路径因人而异，故这里的路径仅为示例，没有真实的文件）
C:\\d.txt   // C盘根目录下的d.txt文件
C:\\e.txt   // C盘当前目录下的e.txt文件
```

#### **mode**
模式根据文件的类型、是否进行读写等等划分为多种类型，也是以字符串表示；  
下面是常见的模式类型及其功能：

|文本文件|二进制文件|含义|
| :--------: | :--: | :--: |
| `r`或`rt` | `rb` | 打开文件用于**只读**，若无该文件则**报错** |
| `r+`或`rt+`或`r+t` | `rb+`或`r+b` | 打开文件用于**读写**，若无该文件则**报错** |
| `w`或`wt` | `wb` | 创建文件用于**只写**，若有该文件则**覆盖原文件** |
| `w+`或`wt+`或`w+t` | `wb+`或`w+b` | 创建文件用于**读写**，若有该文件则**覆盖原文件** |
| `a`或`at` | `ab` | 打开文件用于**追加**，若无该文件则**创建新文件** |
| `a+`或`at+`或`a+t` | `ab+`或`a+b` | 打开文件用于**追加和读**，若无该文件则**创建新文件** |

可以看出，`a`模式可以看作是模式`r`和`w`的融合升级版；  
既解决了`r`模式下的报错问题，又克服了`w`模式下由于新文件会覆盖原文件，导致无法对文件进行修改的缺点；  
所以`a`模式总是可以用的；

打开文件后，函数将会向`FILE*`指针返回对应的文件指针，若发生错误则会返回NULL指针；

以下是文件打开的例子：
```c
FILE *fp1,*fp2;
*fp1=fopen("in.txt","r");   // 打开一个已存在的in.txt文本文件
*fp2=fopen("out.dat","wb"); // 创建一个out.dat二进制文件
```

### 文件的关闭
就如动态内存分配后需要释放内存一样，文件打开后也需要关闭；  
否则写入的内容会因为存放在缓冲区内没有保存，而导致文件操作失败；  
文件关闭的参数是`FILE*`指针，不是文件名；  

`fclose`函数是有返回值的，可以判定文件是否正常关闭；  

除此之外，还提供了一个函数来关闭所有已经打开的文件；它的原型如下：  
```c
int _fcloseall(void)
```

## 文件的读写
文件的读写一般是终端的输入输出在最前面加上f；  
比如`fgetc`，`fputc`，`fgets`，`fputs`等等；  
但是使用的最多的函数还是`fscanf`和`fprintf`两种，它们的原型如下：  
```c
int fscanf(FILE *stream,const char *format [,argument] ...);
int fprintf(FILE *stream,const char *format [,argument] ...);
```
它们的参数就是标准格式化输入输出`scanf`，`printf`在最前面加上了文件指针参数；

### **fscanf**
fscanf函数的文件指针即将要读取数据的文件；

事实上，`scanf`可以看作文件指针是标准输入`stdin`（键盘）的`fscanf`函数；

### **fprintf**
fscanf函数的文件指针即将要写入数据的文件；

事实上，`printf`可以看作文件指针是标准输出`stdout`（屏幕）的`fprintf`函数；

## 文件的重定向
文件的重定向一般涉及到“重开”函数`freopen`；  
它的原型如下：
```c
FILE *freopen(const char *path, const char *mode, FILE *fp);
```

`path`是存储输入输出的文件名的字符串；  
`mode`和`fopen`里面的`mode`一样；  
`fp`是被“重开”文件的指针；  

常见的重定向操作是把标准输入输出文件重定向到文本文件；  
即：
```c
freopen(in.txt,"w",stdin);      // 标准输入重定向到in.txt文本文件
freopen(out.txt,"r",stdout);    // 标准输出重定向到out.txt文本文件
```

在重定向操作之后，之前的标准输入输出函数，像`scanf`、`printf`之类的都不会通过终端读写，而是通过文本文件；

重定向有很多好处，比如储存较大的输入文件，而不是每次都在终端上敲一遍；储存输出文件，并和其它输出进行比较；通过加上和删去重定向的方式，使交互方式在终端和文件里面切换，而不需要更改任何其它内容；

## 实例
### 读写文件内容（**file.c**）
读取位于不同位置的文本文件abc，然后将其内容（**只有一行且没有空格**）写到文本文件d中；
```c
#include <stdio.h>
void ReadAndWriteFile(FILE *p1, FILE *p2)
{
    // 用于记录文件内容
    char str[100]={0};
    // 检测文件是否打开成功
    if(p1==NULL)
    {
        printf("Not Found\n");
        return;
    }
    fscanf(p1,"%s",str);        // 从p1所指文件里读取数据
    fprintf(p2,"%s\n",str);     // 输出数据到p2所指文件
}

int main()
{
    FILE *p1=NULL,*p2=NULL,*p3=NULL,*p4=NULL;
    p1=fopen("a.txt","r");      // 本目录
    p2=fopen("sub\\b.txt","r"); // 子目录
    p3=fopen("..\\c.txt","r");  // 上一目录
    p4=fopen("d.txt","a");      // 输出文件
    ReadAndWriteFile(p1,p4);
    ReadAndWriteFile(p2,p4);
    ReadAndWriteFile(p3,p4);
    _fcloseall();            // 关闭所有文件以正常结束程序
    return 0;
}
```
注：因为使用了`a`模式，所以**不会删除**前面的执行结果；  
因此多次运行该程序会让`d.txt`显示以下结果：  
```
a
b
c
a
b
c
……
```

### 文件重定向（**freopen.c**）
将标准输入输出文件分别重定向到`in.txt`和`out.txt`；  
然后完成`A+B problem`；
```c
#include <stdio.h>
int main()
{
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);

    int a,b;
    scanf("%d%d",&a,&b);
    printf("%d\n",a+b);
    _fcloseall();
    return 0;
}
```
在`in.txt`里面输入2个数，运行程序，然后打开`out.txt`，即可看到结果；