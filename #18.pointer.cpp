/*

*/
#include <stdio.h>
void f(int* q);
void g(int b[]);
int main()
{
	/*
	运算符 & 可以用于获取变量的地址，但是它必须针对变量操作；
	*/
	//例如下面的程序可以看到变量 i 的地址；

	int i = 114;
	printf("&i=%x\n", &i);//地址一般使用十六进制表示；
	/*
	因此在scanf函数中,运作的真正原理是将输入的数据存入指定的地址中，而不是赋值；

	我们可以使用 %p 来获取一个变量的地址；
	*/
	//如下面的例子：
	printf("&i=%p\n", &i);//仍需输入&；
	/*
	可以看到，虽然上下两行代码几乎相同，但是上下两个结果并不相同；
	这是因为编译器的架构不同；%x输出的是整型 int ，而%p输出的是地址的专属变量类型 int*；
	因此要获取一个变量的地址最好还是使用%p；

	前面谈到了 int* ；这就是指针类型的变量；
	指针变量也是储存值的，只不过存的是存放具体值的变量的地址；
	用 int *p = &i; p就可以储存具有实际值的变量i的地址；
	换句话说，p指向了i（ p->i ）；

	需要注意的是，int *p = &i中，&不可以省略，因为你要赋地址给指针；
	而int *p = i，只能给指针 p 传递 i 的值；编译器也会报错；
	*/
	//如下面的例子：
	int* p = &i;
	printf("p=%p\n", p);
	/*
	我们将i的地址赋给了指针p；在输出指针p指向的i的地址时，与&i完全一致；

	除此之外，我们还可以用NULL来表示一个没有指向任何地址的空指针；
	当我们试图找到它的地址时，你就会发现它是0或者是null；
	*/
	//看下面的例子：
	int *r=NULL;
	printf("r=%p\n",r);
	//在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。

	/*
	前面提到运算符 & 可以访问变量所在的地址；
	那么反过来，我们有运算符 * ，可以找到地址所在的变量的值；
	*/
	//如下面的例子：
	printf("i=%d\n", i);
	printf("*p=%d\n", *p);
	/*
	 *p 找到了指针p储存的地址指向的变量i，因此输出i的值，上下两行结果完全一致；
	 可以理解为：*先访问到了p的地址指向的是变量 i ，之后 *p 再将 i 拿来运算；
	*/
	/*
	由此可见，运算符*和&作用相反，互为逆运算符；
	优先级         运算符         运算         结合关系         举例
	  2              *            取值         自右向左      *p（p为指针）
	  2              &           取地址        自右向左      &i（i为变量）

	事实上，在大部分情况下， *p 可以看作 i；&i 可以看作 p ；
	那要这两个运算符和指针有啥用额？
	答案就是：跃过函数赋值！
	我们知道，函数与main之间，只能用值连接，二者其中的变量毫不相干；
	但有了指针，一切就改变了，因为二者的地址是有联系的！
	*/
	//如下面的例子：
	f(p);
	printf("i=%d\n", i);
	/*
	尽管位于不同的函数，但i的地址是唯一的；
	而指针p和q指向的又是同一个地址；
	因此q直接访问到了 main 中的 i，并“隔空”进行了替换；
	在函数的最后，指针p同样被抹去了；但地址已经被修改，且无法被抹去了；
	因此前面i的值还是114，后面就变成514了；
	*/

	/*
	讲完这么多，还剩下一个变态内容！
	好像数组还没有牵扯到指针里面吧？
	那么，告诉你们，数组就是特殊的指针！！
	已知运算符 * 可以访问指针指向的变量的值；
	同理， * 也可以访问数组“指向”的变量，即数组储存的第一个变量；
	*/
	//如下面的例子：
	int a[] = { 1,2,3 };
	printf("a[0]=%d\n", a[0]);
	printf("*a=%d\n", *a);
	/*
	可以看到a[0]和*a的值完全一致，都是1；
	类比于指针，我们可以解释为 * 访问了 a “指向”的变量，正好它就是a作为数组时储存的变量a[0]；
	只不过，数组还能储存更多的变量；

	以此类推，在某些情况下，指针也可以当作数组，使用[]；
	*/
	//如下面的例子：
	printf("p[0]=%d\n", p[0]);
	/*
	可以看到p[0]和*p和i的值完全一致；
	可以解释为p[0]作为1个变量“储存”了1个值，而这个值就是 p 作为指针时访问到的变量 i 的值；
	*/

	/*
	除此之外，用数组定义指针时不用加& ；

	自然，数组也可以有“跃过函数赋值”的操作；
	*/
	
	//如下面的例子：
	g(a);
	printf("a[0]=%d a[1]=%d a[2]=%d\n", a[0], a[1], a[2]);
	/*
	可以看到，无论是 *b 还是 b[1] b[2] 都能成功地对数组a的值进行改动；
	因此，b[1] b[2] 也是取值运算符；它们也是直接访问到 b[1] b[2] 指向的变量的地址，并“隔空”修改变量的值；
	
	对于数组而言,数组储存的变量的地址都是连续的；
	这也就意味着指针也有机会以数组访问的方式访问自己意外的数组变量；
	*/
	//如下面的例子：
	int* q = &a[1];
	printf("q[-1]=%d q[0]=%d q[1]=%d\n", q[-1], q[0], q[1]);

	/*
	数组与指针的不同之处，除了数组能储存更多变量之外，数组访问的地址不可以被改变；
	比如，你不能进行a++来试图改变数组a指向的地址，它永远是a[0]；
	这一点和常数const int 很像；一旦被定义，就不能再被改变；
	实际上，int a[] 实际上等价于 int * const a ；代表指针a是常量；
	数组就是指向的地址不能被改变的常量指针！

	除此之外，还有另一种常量指针，就是 const int *a；
	它的意思是*a是常量；也就无法通过*a或a[0]这些方式来改变它所指的变量的值；
	但它指向的地址可以被改变，即 a++是可行的；

	这两种常量指针的区别在于 a 是常量还是 *a 是常量；
	例如，int const *a；就是 *a 是常量，与第二种常量指针一致；

	当数组被定义成常量时，（ const int a[] ）
	此时数组储存的每一个变量都是常量，同时所指的地址也不能被修改；
	等价于 const int * const a；
	
	指针的好处在于可以跃过函数；但它的坏处也在于此：无需限制就把你外面的变量修改了；
	因此，就可以在函数里面使用常量指针（或数组）；
	一旦你用取值运算符做了修改，编译器就会报错；
	这样就可以保护指针类型的变量不会改变外面的值；

	*/
	return 0;
}
void f(int *q)
{
	*q = 514;
}
void g(int b[])
{
	*b = 4;
	b[1] = 5;
	b[2] = 6;
}

/*
	除此之外，还有指针数组和指向指针的指针；
	理论上可以用指针数组来表示字符串数组，但是感觉没有二维数组那么方便；
*/